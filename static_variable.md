# 静态变量

## 静态变量的生命周期

**在C++中，静态变量（包括静态成员变量和静态局部变量）的生命周期是从程序开始执行时开始，直到程序结束时结束**。它们的存储空间在程序的整个执行期间都是存在的

具体来说，**静态变量的初始化发生在程序执行之前的静态初始化阶段**。**全局静态变量**和**静态成员变量**在**程序加载时进行初始化**，而**局部静态变量**在**第一次执行到它们的定义语句时进行初始化**。

一旦静态变量被初始化，它们将一直存在于内存中，直到程序结束。无论在何处调用静态变量，它们的值都会保持在内存中，直到程序结束。

需要注意的是，**静态变量的可见性和作用域取决于它们的声明位置。全局静态变量在整个程序中可见，而静态局部变量的作用域仅限于定义它们的函数或代码块**。

总结起来，**静态变量的生命周期从程序开始执行时开始，直到程序结束时结束**。它们的值在整个程序执行期间保持不变，且存储空间一直存在

```C++
#include "stadfx.h"

static int a=1;

int main()
{

    int c=3;

    {
        static int b=2;
        std::cout<<a<<' '<<b<<std::endl;
    }
    //b超出作用范围，无法访问
    //std::cout<<a<<' '<<b<<std::endl;
    std::cout<<a<<std::endl;

    return 0;
}

```

![](C:\Users\WLSD\AppData\Roaming\Typora\typora-user-images\image-20230605203740448.png)

#### 特别注意：

**b之所以无法输出，是因为超出了作用范围，但是程序main结束之前仍存在在内存中**



### 全局静态变量

**具体地说，全局静态变量和静态成员变量在程序加载时进行初始化，这发生在`main()`函数执行之前。**在程序启动时，操作系统会为全局变量分配内存，并将其初始化为默认值（对于静态成员变量，还要考虑类内的初始化）。**静态变量的初始化顺序与其在源文件中的定义顺序有关**



```C++
static int a=1;

int main()
   //a在main之前初始化默认为0
```



### 局部静态变量

```C++

int main()
{

    int c=3;

    {
        static int b=2;//b执行到这一步是才被初始化
        std::cout<<a<<' '<<b<<std::endl;
    }
```



## 静态函数

**静态变量只能被静态函数访问**

静态函数（或称为静态成员函数）在C++中有一些特殊的用途和特性。

1. **访问静态成员：**静态函数可以直接访问类的静态成员变量和静态成员函数，无需通过对象实例来访问。这是因为静态函数属于类而不是对象，它与类的实例无关。这使得静态函数可以作为访问和操作类级别数据的接口。

2. **不依赖于对象：**静态函数不需要通过对象实例来调用，可以直接使用类名和作用域解析运算符`::`来调用。这意味着静态函数可以在没有类的实例的情况下使用。

3. **作为工具函数：**静态函数常常被用作工具函数，它们可以提供一些与类相关但不依赖于特定对象实例的功能。这些函数通常是对静态成员进行操作，或者执行与类相关的计算。

4. **隐藏实现细节：**静态函数可以被声明为类的私有成员，从而隐藏实现细节。这样，只有类内部的其他成员函数才能调用它们，外部代码无法直接访问。

需要注意的是，**静态函数没有隐式的`this`指针，因为它们不依赖于对象实例**。**这意味着静态函数无法访问非静态成员变量和非静态成员函数**，因为这些成员是与对象实例相关的。

总结而言，静态函数在C++中有其特殊的用途，**可以用于访问静态成员、提供类级别的功能、隐藏实现细节等**。**它们不依赖于对象实例，可以直接通过类名进行调用。**



## 静态成员变量

静态类变量（或称为静态成员变量）是**属于整个类**而不是类的实例的变量。**它与类的每个对象实例无关，只有一份拷贝存在于内存中**。

静态类变量具有以下特点：

1. **共享性：**静态类变量被所有该类的对象实例所共享，它们在内存中只有一个副本。无论创建多少个对象实例，静态类变量的值都是相同的。

2. **生命周期：**静态类变量的生命周期与程序的运行周期相同，从程序开始执行到结束。它们在程序加载时进行初始化，并且一直存在于内存中，直到程序结束。

3. **访问权限：**静态类变量可以在类的内部和外部直接访问，无需通过对象实例。类的成员函数可以直接访问静态类变量，而无需使用对象的引用或指针。

4. **初始值：**静态类变量在定义时可以指定初始值，如果没有显式指定初始值，则会被**默认初始化为零值**（对于数值类型）或空值（对于指针、字符串等类型）。

**静态类变量通常用于存储与整个类相关的数据，而不是与特定对象实例相关的数据**。它们可以用于**跟踪类的状态**、**计数对象的数量**、**共享资源**等。

在C++中，**静态类变量的声明必须在类的内部进行，并且需要在类的外部进行定义和初始化**。**这样可以确保只有一份静态类变量的实例存在。**

以下是一个示例，展示了如何声明、定义和使用静态类变量：

```cpp
class MyClass {
public:
    static int count;  // 声明静态类变量

    MyClass() {
        count++;  // 在构造函数中修改静态类变量的值
    }
};

int MyClass::count = 0;  // 定义和初始化静态类变量

int main() {
    MyClass obj1;
    MyClass obj2;
    MyClass obj3;

    std::cout << "Object count: " << MyClass::count << std::endl;  // 访问静态类变量

    return 0;
}
```

在上述示例中，`MyClass` 类包含一个静态类变量 `count`，用于记录创建的对象数量。每次创建 `MyClass` 对象时，构造函数会增加 `count` 的值。通过使用 `MyClass::count`，我们可以在 `main()` 函数中访问和输出静态类变量的值。

希望这解答了你的问题。如果还有疑问，请随时提问。